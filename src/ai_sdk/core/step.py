"""Step system for multi-step AI generation workflows."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Union

from ..providers.types import Content, FinishReason, Message, Usage
from ..tools.core import ToolCall, ToolResult


@dataclass
class GeneratedFile:
    """Represents a file generated by the AI model."""
    
    name: str
    content_type: str
    content: bytes
    url: Optional[str] = None
    
    @property
    def size(self) -> int:
        """Get the size of the file in bytes."""
        return len(self.content)
    
    def save_to_path(self, path: str) -> None:
        """Save the file to the specified path."""
        with open(path, 'wb') as f:
            f.write(self.content)


@dataclass
class StepResult:
    """Result of a single generation step in a multi-step workflow."""
    
    # Core content
    content: List[Content]
    text: str
    finish_reason: FinishReason
    usage: Usage
    
    # Tool-related results
    tool_calls: List[ToolCall]
    tool_results: List[ToolResult]
    
    # Advanced content types
    files: List[GeneratedFile]
    reasoning_text: Optional[str] = None
    reasoning: Optional[List[Dict[str, Any]]] = None
    sources: Optional[List[Dict[str, Any]]] = None
    
    # Metadata
    warnings: Optional[List[str]] = None
    provider_metadata: Optional[Dict[str, Any]] = None
    request: Optional[Dict[str, Any]] = None
    response: Optional[Dict[str, Any]] = None
    
    # Step information
    step_number: int = 0
    
    @property
    def has_tool_calls(self) -> bool:
        """Check if this step has any tool calls."""
        return len(self.tool_calls) > 0
    
    @property
    def has_tool_results(self) -> bool:
        """Check if this step has any tool results."""
        return len(self.tool_results) > 0
    
    @property
    def static_tool_calls(self) -> List[ToolCall]:
        """Get tool calls that are not dynamic."""
        return [tc for tc in self.tool_calls if not tc.dynamic]
    
    @property
    def dynamic_tool_calls(self) -> List[ToolCall]:
        """Get dynamic tool calls."""
        return [tc for tc in self.tool_calls if tc.dynamic]
    
    @property
    def static_tool_results(self) -> List[ToolResult]:
        """Get tool results that are not from dynamic tools."""
        return [tr for tr in self.tool_results if not tr.dynamic]
    
    @property
    def dynamic_tool_results(self) -> List[ToolResult]:
        """Get tool results from dynamic tools."""
        return [tr for tr in self.tool_results if tr.dynamic]


class StopCondition:
    """Base class for stop conditions in multi-step generation."""
    
    async def is_met(self, steps: List[StepResult]) -> bool:
        """Check if this stop condition is met."""
        raise NotImplementedError
    
    def __call__(self, steps: List[StepResult]) -> bool:
        """Synchronous version for simple conditions."""
        raise NotImplementedError


class StepCountCondition(StopCondition):
    """Stop condition based on number of steps."""
    
    def __init__(self, count: int) -> None:
        self.count = count
    
    async def is_met(self, steps: List[StepResult]) -> bool:
        return len(steps) >= self.count
    
    def __call__(self, steps: List[StepResult]) -> bool:
        return len(steps) >= self.count


class HasToolCallCondition(StopCondition):
    """Stop condition when a tool call is present."""
    
    def __init__(self, tool_name: Optional[str] = None) -> None:
        self.tool_name = tool_name
    
    async def is_met(self, steps: List[StepResult]) -> bool:
        if not steps:
            return False
        
        last_step = steps[-1]
        if not last_step.has_tool_calls:
            return False
        
        if self.tool_name is None:
            return True
        
        return any(tc.tool_name == self.tool_name for tc in last_step.tool_calls)
    
    def __call__(self, steps: List[StepResult]) -> bool:
        if not steps:
            return False
        
        last_step = steps[-1]
        if not last_step.has_tool_calls:
            return False
        
        if self.tool_name is None:
            return True
        
        return any(tc.tool_name == self.tool_name for tc in last_step.tool_calls)


def step_count_is(count: int) -> StepCountCondition:
    """Create a stop condition that stops after a specific number of steps."""
    return StepCountCondition(count)


def has_tool_call(tool_name: Optional[str] = None) -> HasToolCallCondition:
    """Create a stop condition that stops when a tool call is present."""
    return HasToolCallCondition(tool_name)


async def is_stop_condition_met(
    stop_conditions: Union[StopCondition, List[StopCondition]],
    steps: List[StepResult]
) -> bool:
    """Check if any of the stop conditions are met."""
    if isinstance(stop_conditions, StopCondition):
        stop_conditions = [stop_conditions]
    
    for condition in stop_conditions:
        if await condition.is_met(steps):
            return True
    
    return False


@dataclass
class PrepareStepArgs:
    """Arguments passed to prepare step function."""
    
    model: Any  # LanguageModel - avoiding circular import
    steps: List[StepResult]
    step_number: int
    messages: List[Message]


@dataclass
class PrepareStepResult:
    """Result from preparing a step."""
    
    model: Optional[Any] = None  # LanguageModel
    system: Optional[str] = None
    messages: Optional[List[Message]] = None
    tools: Optional[Dict[str, Any]] = None  # Dict[str, Tool]
    tool_choice: Optional[Union[str, Dict[str, Any]]] = None
    active_tools: Optional[List[str]] = None
    max_tokens: Optional[int] = None
    temperature: Optional[float] = None
    top_p: Optional[float] = None
    top_k: Optional[int] = None
    frequency_penalty: Optional[float] = None
    presence_penalty: Optional[float] = None
    stop: Optional[Union[str, List[str]]] = None
    seed: Optional[int] = None


# Type alias for prepare step function
PrepareStepFunction = Optional[callable]  # Callable[[PrepareStepArgs], Awaitable[Optional[PrepareStepResult]]]